# 基于redis

**如何用Redis实现分布式锁？**

Redis分布式锁的基本流程并不难理解，但要想写得尽善尽美，也并不是那么容易。在这里，我们需要先了解分布式锁实现的三个核心要素：

**1.加锁**

最简单的方法是使用setnx命令。key是锁的唯一标识，按业务来决定命名。比如想要给一种商品的秒杀活动加锁，可以给key命名为 “lock\_sale\_商品ID” 。而value设置成什么呢？我们可以姑且设置成1。加锁的伪代码如下：

```
setnx（key，1）
```

当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败。

**2.解锁**

有加锁就得有解锁。当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式是执行del指令，伪代码如下：

```
del（key）
```

释放锁之后，其他线程就可以继续执行setnx命令来获得锁。

**3.锁超时**

锁超时是什么意思呢？如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住，别的线程再也别想进来。

所以，setnx的key必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放。setnx不支持超时参数，所以需要额外的指令，伪代码如下：

```
expire（key， 30）
```

综合起来，我们分布式锁实现的第一版伪代码如下：

```
if（setnx（key，1） == 1）{
expire（key，30）
try {
do something ……

} finally {
del（key）
}
}
```



